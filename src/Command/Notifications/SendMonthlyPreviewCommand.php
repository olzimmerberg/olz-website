<?php

namespace Olz\Command\Notifications;

use Doctrine\Common\Collections\Criteria;
use Doctrine\Common\Collections\Order;
use Olz\Entity\NotificationSubscription;
use Olz\Entity\Termine\Termin;
use Olz\Utils\WithUtilsTrait;
use Symfony\Component\Console\Attribute\AsCommand;

#[AsCommand(name: 'olz:send-monthly-preview')]
class SendMonthlyPreviewCommand extends BaseSendNotificationsCommand {
    use WithUtilsTrait;

    public function getNotificationSubscriptionType(): string {
        return NotificationSubscription::TYPE_MONTHLY_PREVIEW;
    }

    public function autogenerateSubscriptions(): void {
        // Must be generated by user.
    }

    /** @param array<string, mixed> $args */
    public function getNotification(array $args): ?Notification {
        $current_weekday = intval($this->dateUtils()->getCurrentDateInFormat('N'));
        $saturday = 6;
        if ($current_weekday != $saturday) {
            return null;
        }
        $day_of_month = intval($this->dateUtils()->getCurrentDateInFormat('j'));
        $total_days_of_month = intval($this->dateUtils()->getCurrentDateInFormat('t'));
        if ($day_of_month <= $total_days_of_month - 14) {
            return null; // not yet this month
        }
        if ($day_of_month > $total_days_of_month - 7) {
            return null; // not anymore this month
        }

        $one_month = \DateInterval::createFromDateString('+1 months');
        $two_months = \DateInterval::createFromDateString('+2 months');
        $today = new \DateTime($this->dateUtils()->getIsoToday());
        $next_month = (new \DateTime($this->dateUtils()->getIsoToday()))->add($one_month);
        $in_two_months = (new \DateTime($this->dateUtils()->getIsoToday()))->add($two_months);
        $end_of_timespan = new \DateTime($in_two_months->format('Y-m-01'));

        $notification_text = '';
        $termine_text = $this->getTermineText($today, $end_of_timespan);
        if (strlen($termine_text) > 0) {
            $notification_text .= "\n**Termine**\n\n{$termine_text}\n";
        }
        $deadlines_text = $this->getDeadlinesText($today, $end_of_timespan);
        if (strlen($deadlines_text) > 0) {
            $notification_text .= "\n**Meldeschlüsse**\n\n{$deadlines_text}\n";
        }

        if (strlen($notification_text) == 0) {
            return null;
        }

        $month_name = $this->dateUtils()->olzDate('MM', $next_month);
        $title = "Monatsvorschau {$month_name}";
        $text = "Hallo %%userFirstName%%,\n\nIm {$month_name} haben wir Folgendes auf dem Programm:\n\n{$notification_text}";

        return new Notification($title, $text, [
            'notification_type' => NotificationSubscription::TYPE_MONTHLY_PREVIEW,
        ]);
    }

    public function getTermineText(\DateTime $today, \DateTime $end_of_timespan): string {
        $termin_repo = $this->entityManager()->getRepository(Termin::class);
        $criteria = Criteria::create()
            ->where(Criteria::expr()->andX(
                Criteria::expr()->gt('start_date', $today),
                Criteria::expr()->lt('start_date', $end_of_timespan),
                Criteria::expr()->eq('on_off', 1),
            ))
            ->orderBy(['start_date' => Order::Ascending])
            ->setFirstResult(0)
            ->setMaxResults(1000)
        ;
        $termine = $termin_repo->matching($criteria);

        $base_href = $this->envUtils()->getBaseHref();
        $code_href = $this->envUtils()->getCodeHref();

        $termine_url = "{$base_href}{$code_href}termine";
        $termine_text = "";
        foreach ($termine as $termin) {
            $id = $termin->getId();
            $starts_on = $termin->getStartDate();
            $ends_on = $termin->getEndDate();
            $date = ($ends_on && $ends_on > $starts_on)
                ? $this->dateUtils()->compactDate($starts_on).' - '.$this->dateUtils()->compactDate($ends_on)
                : $this->dateUtils()->compactDate($starts_on);
            $title = $termin->getTitle();
            $termine_text .= "- {$date}: [{$title}]({$termine_url}/{$id})\n";
        }
        return $termine_text;
    }

    public function getDeadlinesText(\DateTime $today, \DateTime $end_of_timespan): string {
        $termin_repo = $this->entityManager()->getRepository(Termin::class);

        $base_href = $this->envUtils()->getBaseHref();
        $code_href = $this->envUtils()->getCodeHref();
        $termine_url = "{$base_href}{$code_href}termine";

        $deadlines_text = '';

        $criteria = Criteria::create()
            ->where(
                Criteria::expr()->andX(
                    Criteria::expr()->gt('deadline', $today),
                    Criteria::expr()->lt('deadline', $end_of_timespan),
                    Criteria::expr()->eq('on_off', 1),
                )
            )
            ->orderBy(['start_date' => Order::Ascending])
            ->setFirstResult(0)
            ->setMaxResults(1000)
        ;
        $deadlines = $termin_repo->matching($criteria);
        foreach ($deadlines as $termin) {
            $deadline_date = $termin->getDeadline();
            $date = $deadline_date ? $this->dateUtils()->compactDate($deadline_date) : '';
            $id = $termin->getId();
            $title = $termin->getTitle();
            $deadlines_text .= "- {$date}: Meldeschluss für '[{$title}]({$termine_url}/{$id})'\n";
        }

        return $deadlines_text;
    }
}
